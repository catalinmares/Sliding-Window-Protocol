# Sliding Window Protocol

In implementarea mea am abordat proiectul pas cu pas. Am implementat initial transmisia normala a fisierului pentru care nu a fost nevoie de mult efort.

	Ulterior, pentru urmatoarele 20 de puncte, pierderea cadrelor mi-a dat mari batai de cap. Am incercat sa implementez protocolul cu "Selective Repeat", ceea ce a fost o adevarata provocare. Am rescris proiectul de mai bine de 10 ori. 
	
	Apoi am decis sa abordez altfel. Am implementat protocolul cu "Go Back N" si s-a dovedit ineficient din punct de vedere temporal, mai ales cand venea vorba de ferestre de sute de cadre. Pe baza protocolului "Go Back N" mi-am construit in cele din urma protocolul "Selective Repeat" care s-a dovedit a fi functional in cele din urma. 
	
	Pentru asta, am implementat initial o coada pe care am folosit-o in sender. In momentul in care trimiteam un cadru, il introduceam in coada astfel incat, in orice moment, in coada sa se afle cadrele trimise si neconfirmate (practic, fereastra senderului). In momentul in care primeam ACK pentru un cadru, scoteam din coada toate cadrele dinaintea lui si le retrimiteam, reintroducandu-le in coada, scoteam cadrul pentru care am primit ACK si trimiteam un cadru nou. 
	
	In receiver, am incercat in prima instanta sa folosesc un minheap ca sa retin cadrele pe care le primeam si care aveau un numar de secventa diferit de cel asteptat pentru a-l scrie in fisier. Abordarea asta a esuat, motiv pentru care am decis sa imi aloc un buffer in care sa memorez fisierul bucata cu bucata in timp ce il primeam. De fiecare data cand primeam un cadru, in functie de numarul lui de secventa, stiam de la ce offset sa incep sa scriu in buffer si cat sa scriu.
	
	Pentru inca 20 de puncte, am implementat o functie de calculare a unui checksum. In structura mea pe care o introduceam in payload aveam un payload mai mic si 2 intregi, unul in care tineam numarul de secventa al cadrului si unul in care tineam un checksum. Checksum-ul l-am calculat facand XOR intre octetii scrisi in payload-ul structurii mele si intre cei 4 octeti din intregul in care tineam numarul de secventa. La receiver, reapelam pentru cadrul primit aceeasi functie si verificam ca checksum-urile sa coincida. Aici am intalnit 2 cazuri: fie se corupea payload-ul sau numarul de secventa, caz in care checksum-ul dadea diferit, fie se corupea direct checksum-ul, caz in care nu ar fi mai dat oricum egalitate. Daca receiverul identifica un cadru ca fiind corupt, acesta trimitea NAK, iar senderul retrimitea acel cadru.
	
	Pentru ultimele 25 de puncte, a trebuit sa abordez altfel, deoarece metoda folosita anterior nu ar fi mers. Am inlocuit coada cu o lista si in momentul in care primeam ACK pentru un cadru, il eliminam din lista si trimiteam un cadru nou pe care il introduceam la randul lui in lista. Astfel, nu conteaza ce primeste receiverul si in ce ordine, senderul va scoate din lista tot ce receiverul ii confirma. Daca se pierd multe cadre si se goleste fereastra, senderul nu va mai primi ACK, caz in care va retrimite toate cadrele ramase in lista. 

	Am incercat sa abordez aceasta tema cat de eficient am putut. M-am luptat incontinuu cu checkerul si cu multele probleme cu care acesta a venit. Inca am o problema la testul 3 de la stress, acesta uneori trecand, iar alteori nu. Nu inteleg motivul si chiar mi-ar placea sa primesc feedback pentru aceasta tema in care sa mi se spuna ce as fi mai putut optimiza pentru a obtine timpi de rulare mai scurti. Testele imi trec toate cu fisierele identice, singura problema fiind la acel test, in care programul meu se pare ca e putin mai "lenes". Am incarcat si pe VMChecker, am rulat de mai multe ori si pe local si de cele mai multe ori obtin 85, insa uneori programul mai intampina dificultati la acel test si da TIMEOUT, obtinand 80 de puncte.
	
	Cat despre timeout-ul ales, nu este pus la intamplare. Am analizat operatiile pe care le fac in receiver si am considerat ca pentru delay-uri mici este nevoie de un timeout de 4 ori mai mare decat delay-ul, astfel incat sender-ul sa poata face toate operatiile necesare inainte de a trimite un reply.
